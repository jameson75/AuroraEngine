I. Handling Key/Gamepad/Mouse Input
-----------------------------------

Input events are NOT routed to controls like in win32/Winforms/WPF,etc. 
The idea was not to stray too far away from the natural flow of a game
loop, where device states are, more commonly, polled.

The device state is polled. The GameApp does this at the begining of the
game loop. The real-time-input-state (ImputState) and buffered-input-state
(BufferedInputSate - where the scan rate of keys being held down is throttled)
are captured. These states can be retreived usin the InputService service.

Typcially, as an optimization, a control will only attempt to update
its state if it has focus (UIControl.HasFocus). 

II. Rerouting commands from child controls
------------------------------------------

As mentioned, input events aren't routed to controls but, when a control
finishes invoking some command (typicall as a result of an input event)
the control fires an OnCommand event. Controls which do, 
implement the ICommandControl interface.

In a situation where a control contains children which fire oncommand events,
we want the parent control to also fire this event. In other words, we want
the command to be "wired up". Parent controls that want the command events of
their children auto-magically wired up can do so by implementing the ICommandDispatcher
inteface and then instanciating the CommandControlWireUp class, passing itself to the
constructor.

III. Overriding focus management
--------------------------------

